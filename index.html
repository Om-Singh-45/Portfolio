<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Om Singh - Portfolio</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Add particles.js library -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #4f46e5;
            --accent-color: #06b6d4;
            --dark-color: #111111;
            --text-color: #e2e8f0;
            --text-muted: #94a3b8;
            --card-bg: rgba(17, 24, 39, 0.7);
            --card-border: rgba(255, 255, 255, 0.05);
            --planet-glow: rgba(255, 255, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            line-height: 1.6;
            color: var(--text-color);
            background: linear-gradient(145deg, #000110, #07032a);
            overflow-x: hidden;
            position: relative;
            cursor: none;
        }

        a {
            text-decoration: none;
            color: var(--primary-color);
        }

        ul {
            list-style: none;
        }

        img {
            max-width: 100%;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .btn {
            display: inline-block;
            padding: 12px 30px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            transition: transform 0.3s ease, background-color 0.3s ease;
            font-size: 16px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
            transform: translateY(-3px);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
        }

        .btn-outline:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-3px);
        }

        /* Navbar */
        .navbar {
            background-color: rgba(9, 9, 15, 0.9);
            color: white;
            padding: 15px 0;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            transition: background-color 0.3s ease;
        }

        .navbar.scrolled {
            background-color: rgba(7, 7, 15, 0.95);
        }

        .navbar .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .navbar .logo {
            font-size: 24px;
            font-weight: 700;
            color: white;
        }

        .navbar .logo span {
            color: var(--primary-color);
        }

        .navbar ul {
            display: flex;
        }

        .navbar ul li {
            margin-left: 20px;
        }

        .navbar ul li a {
            color: var(--text-muted);
            font-weight: 500;
            transition: color 0.3s;
        }

        .navbar ul li a:hover {
            color: white;
        }

        .mobile-menu-btn {
            display: none;
            cursor: pointer;
        }

        /* Hero Section */
        .hero {
            background-size: cover;
            background-position: center;
            height: 100vh;
            display: flex;
            align-items: center;
            color: white;
            text-align: center;
            position: relative;
            z-index: 10;
        }

        .hero .content {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: rgba(9, 9, 12, 0.5);
            border-radius: 10px;
        }

        .hero h1 {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .hero p {
            font-size: 18px;
            margin-bottom: 20px;
            color: var(--text-muted);
        }

        .hero .name {
            color: var(--primary-color);
            font-weight: 700;
        }

        .hero .social-links {
            margin-top: 20px;
        }

        .hero .social-links a {
            margin: 0 10px;
            font-size: 20px;
            color: var(--text-muted);
            transition: color 0.3s, transform 0.3s;
        }

        .hero .social-links a:hover {
            color: white;
            transform: translateY(-3px);
        }

        .hero .btn-group {
            margin-top: 20px;
        }

        .hero .btn-group .btn {
            margin: 0 8px;
        }

        /* About Section */
        .about {
            padding: 80px 0;
            position: relative;
            z-index: 10;
        }

        .section-title {
            text-align: center;
            font-size: 32px;
            margin-bottom: 40px;
            color: white;
        }

        .about .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: center;
        }

        .about .image {
            border-radius: 10px;
            overflow: hidden;
            height: 300px;
            width: 300px;
            margin: 0 auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .about .image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .about .text {
            background-color: rgba(15, 15, 25, 0.7);
            border-radius: 10px;
            padding: 20px;
        }

        .about .text h3 {
            font-size: 24px;
            margin-bottom: 15px;
            color: white;
        }

        .about .text p {
            margin-bottom: 15px;
            color: var(--text-muted);
            font-size: 16px;
        }

        .about .info-item {
            display: flex;
            margin-bottom: 10px;
            align-items: center;
        }

        .about .info-item i {
            margin-right: 10px;
            color: var(--primary-color);
            font-size: 18px;
        }

        .about .btn {
            margin-top: 20px;
        }

        /* Skills Section */
        .skills {
            padding: 80px 0;
            position: relative;
            z-index: 10;
        }

        .skills .container {
            max-width: 1000px;
        }

        .skills-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .skill-category {
            background-color: rgba(15, 15, 25, 0.7);
            border-radius: 10px;
            padding: 20px;
            transition: transform 0.3s ease;
        }

        .skill-category:hover {
            transform: translateY(-5px);
        }

        .skill-category h3 {
            font-size: 20px;
            margin-bottom: 15px;
            color: white;
        }

        .skill-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .skill-item {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            padding: 8px 12px;
            font-size: 14px;
            color: var(--text-muted);
            transition: background-color 0.3s;
        }

        .skill-item:hover {
            background-color: var(--primary-color);
            color: white;
        }

        /* Skills styling with progress bars */
        .skill-progress {
            margin-bottom: 15px;
        }
        
        .skill-name {
            margin-bottom: 5px;
            color: var(--text-color);
            font-weight: 500;
        }
        
        .progress-container {
            height: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            border-radius: 4px;
            width: 0;
            transition: width 1.5s ease-in-out;
        }
        
        /* Animated elements */
        .fade-in {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }
        
        .fade-in.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .bounce-in {
            animation: bounceIn 1s;
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Projects Section */
        .projects {
            padding: 80px 0;
            position: relative;
            z-index: 10;
        }

        .projects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 30px;
        }

        .project-card {
            background-color: rgba(15, 15, 25, 0.7);
            border-radius: 10px;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            will-change: transform;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .project-card:hover {
            transform: translateY(-5px) rotateX(5deg) rotateY(5deg);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
        }

        .project-card .tilt-box {
            transition: transform 0.2s ease-out;
            transform-style: preserve-3d;
        }

        .project-image {
            height: 180px;
            overflow: hidden;
            transform: translateZ(20px);
        }

        .project-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s ease;
        }

        .project-card:hover .project-image img {
            transform: scale(1.05);
        }

        .project-content {
            padding: 20px;
            transform: translateZ(30px);
        }

        .project-title {
            font-size: 20px;
            margin-bottom: 10px;
            color: white;
        }

        .project-description {
            margin-bottom: 15px;
            color: var(--text-muted);
            font-size: 14px;
        }

        .project-tech {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .tech-badge {
            background-color: var(--primary-color);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
        }

        .project-links a {
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            color: var(--text-muted);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.3s, color 0.3s;
        }

        .project-links a:hover {
            background-color: var(--primary-color);
            color: white;
        }

        /* Contact Section */
        .contact {
            padding: 80px 0;
            position: relative;
            z-index: 10;
        }

        .contact .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .contact-info, .contact-form {
            background-color: rgba(15, 15, 25, 0.7);
            padding: 20px;
            border-radius: 10px;
        }

        .contact-info h3, .contact-form h3 {
            font-size: 24px;
            margin-bottom: 15px;
            color: white;
        }

        .contact-info-item {
            display: flex;
            margin-bottom: 15px;
        }

        .contact-info-item i {
            font-size: 20px;
            color: var(--primary-color);
            margin-right: 15px;
        }

        .contact-info-item .content h4 {
            font-size: 16px;
            margin-bottom: 5px;
            color: white;
        }

        .contact-info-item .content p {
            color: var(--text-muted);
            font-size: 14px;
        }

        .contact-social-links a {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 35px;
            height: 35px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            color: var(--text-muted);
            font-size: 16px;
            transition: background-color 0.3s, transform 0.3s;
        }

        .contact-social-links a:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-3px);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-color);
        }

        .form-control {
            width: 100%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 14px;
            color: var(--text-color);
            transition: border-color 0.3s;
        }

        .form-control:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        .form-btn {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
        }

        .form-btn:hover {
            background-color: var(--secondary-color);
            transform: translateY(-3px);
        }

        /* Footer */
        .footer {
            background-color: rgba(9, 9, 9, 0.95);
            color: white;
            padding: 30px 0;
            text-align: center;
            position: relative;
            z-index: 10;
        }

        .footer p {
            margin-bottom: 15px;
            color: var(--text-muted);
        }

        .footer .social-links {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .footer .social-links a {
            width: 35px;
            height: 35px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            color: var(--text-muted);
            font-size: 16px;
            transition: background-color 0.3s, transform 0.3s;
        }

        .footer .social-links a:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-3px);
        }

        .footer .copyright {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Scroll to Top */
        .scroll-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 99;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        }

        .scroll-top.show {
            opacity: 1;
        }

        .scroll-top:hover {
            transform: translateY(-3px);
        }

        /* Cosmic Background */
        .cosmic-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -100;
            pointer-events: none;
            overflow: hidden;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: #fff;
            border-radius: 50%;
            opacity: 0.7;
            animation: twinkle 2s infinite alternate;
        }

        .falling-star {
            position: absolute;
            width: 2px;
            height: 20px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), transparent);
            animation: fall 5s linear infinite;
        }

        @keyframes twinkle {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.2); }
        }

        @keyframes fall {
            0% { transform: translate(0, -10vh) rotate(45deg); opacity: 1; }
            100% { transform: translate(100vw, 100vh) rotate(45deg); opacity: 0; }
        }

        .planet {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ffffff, #4b5e91, #2b3a67);
            box-shadow: 0 0 20px var(--planet-glow);
            animation: float 20s infinite linear;
            display: block;
        }

        .planet.ring {
            background: radial-gradient(circle at 30% 30%, #f4e4bc, #d4a373, #8b5e34);
        }

        .planet.ring::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 150%;
            height: 20%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: translate(-50%, -50%) rotate(45deg);
            border-radius: 50%;
        }

        .planet.small {
            width: 50px;
            height: 50px;
        }

        .planet.medium {
            width: 80px;
            height: 80px;
        }

        .spaceship {
            position: absolute;
            width: 80px;
            height: 80px;
            background: url('https://via.placeholder.com/80x80.png?text=UFO') no-repeat center;
            background-size: contain;
            animation: orbit 30s linear infinite; /* Faster movement */
        }

        @keyframes float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
            100% { transform: translateY(0); }
        }

        @keyframes orbit {
            0% { transform: translate(0, 0); }
            25% { transform: translate(80vw, 20vh); }
            50% { transform: translate(100vw, 80vh); }
            75% { transform: translate(20vw, 100vh); }
            100% { transform: translate(0, 0); }
        }

        @keyframes scrollAnimation {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .cosmic-element {
            animation: scrollAnimation 1s ease-out forwards;
        }

        /* Mobile Responsive */
        @media (max-width: 992px) {
            .about .container,
            .contact .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .about .image {
                width: 250px;
                height: 250px;
            }

            .planet {
                display: block;
            }
        }

        @media (max-width: 768px) {
            .hero h1 {
                font-size: 36px;
            }

            .hero p {
                font-size: 16px;
            }

            .navbar ul {
                position: fixed;
                top: 0;
                right: -100%;
                height: 100vh;
                width: 60%;
                background-color: #111827;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                transition: right 0.3s ease;
            }

            .navbar ul.active {
                right: 0;
            }

            .navbar ul li {
                margin: 10px 0;
            }

            .mobile-menu-btn {
                display: block;
                font-size: 20px;
            }

            .mobile-close-btn {
                position: absolute;
                top: 15px;
                right: 15px;
                font-size: 20px;
                cursor: pointer;
            }

            .cosmic-background {
                display: block;
            }

            .spaceship {
                animation-duration: 15s; /* Faster movement on mobile */
            }
        }

        @media (max-width: 576px) {
            .hero h1 {
                font-size: 28px;
            }

            .hero p {
                font-size: 14px;
            }

            .hero .btn-group .btn {
                display: block;
                width: 100%;
                margin: 8px 0;
            }

            .section-title {
                font-size: 24px;
            }

            .about .image {
                width: 200px;
                height: 200px;
            }
        }

        /* Animation */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate {
            animation: fadeInUp 0.5s ease-out forwards;
        }

        /* Particle background */
        #particles-js {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: -90;
        }

        /* Typewriter effect */
        .typewriter {
            font-size: 20px;
            margin-bottom: 20px;
            color: var(--text-muted);
        }
        
        #typewriter-text {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .cursor {
            display: inline-block;
            width: 2px;
            background-color: var(--text-color);
            margin-left: 2px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }

        /* Custom cursor styles */
        .cursor-dot {
            width: 8px;
            height: 8px;
            background-color: var(--primary-color);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .cursor-outline {
            width: 30px;
            height: 30px;
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9998;
            opacity: 0;
            transition: transform 0.2s, opacity 0.3s;
        }
        
        a, button, .btn, .project-card {
            cursor: none;
        }
        
        body {
            cursor: none;
        }
        
        /* Hide custom cursor on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .cursor-dot, .cursor-outline {
                display: none;
            }
            
            body, a, button, .btn, .project-card {
                cursor: auto;
            }
        }

        /* Floating contact button */
        .floating-contact {
            position: fixed;
            right: 20px;
            bottom: 80px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: 50px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            z-index: 98;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s, box-shadow 0.3s;
            animation: pulse 2s infinite;
        }
        
        .floating-contact:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            animation: none;
        }
        
        .floating-icon {
            font-size: 20px;
        }
        
        .floating-text {
            font-weight: 600;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Skills Galaxy */
        .skills-galaxy-container {
            position: relative;
            width: 100%;
            height: 100vh; /* Full viewport height */
            overflow: hidden;
            background-color: transparent; /* Transparent background */
            margin-top: -40px; /* Negative margin to blend with background */
            margin-bottom: -40px;
            z-index: 5; /* Ensure the container is visible */
        }

        #skillsGalaxy {
            width: 100%;
            height: 100%;
            cursor: pointer;
            position: relative;
            z-index: 5;
        }

        .skill-detail-popup {
            position: fixed; /* Fixed position for better visibility */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 300px;
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 0 40px rgba(6, 182, 212, 0.6);
            z-index: 200;
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.2, 0.85, 0.4, 1.5), opacity 0.5s ease;
            border: 1px solid var(--accent-color);
        }

        .skill-detail-popup.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .skill-detail-content {
            text-align: center;
        }

        .skill-detail-content h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 22px;
        }

        .skill-detail-level {
            margin-bottom: 15px;
        }

        .skill-detail-content p {
            margin-bottom: 20px;
            color: var(--text-muted);
        }

        #closeSkillDetail {
            width: 100%;
        }
    </style>
</head>
<body>
    <!-- Particles Background -->
    <div id="particles-js"></div>

    <!-- Cosmic Background -->
    <div class="cosmic-background">
        <div id="starsContainer"></div>
        <div id="fallingStarsContainer"></div>
        <div id="planetsContainer"></div>
        <div id="spaceshipContainer"></div>
    </div>

    <!-- Custom cursor elements -->
    <div class="cursor-dot" id="cursor-dot"></div>
    <div class="cursor-outline" id="cursor-outline"></div>

    <!-- Navbar -->
    <nav class="navbar">
        <div class="container">
            <a href="#home" class="logo">Om<span>Singh</span></a>
            <ul id="menu">
                <li><a href="#home">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#skills">Skills</a></li>
                <li><a href="#projects">Projects</a></li>
                <li><a href="#contact">Contact</a></li>
                <div class="mobile-close-btn" id="close-menu">
                    <i class="fas fa-times"></i>
                </div>
            </ul>
            <div class="mobile-menu-btn" id="open-menu">
                <i class="fas fa-bars"></i>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section id="home" class="hero">
        <div class="content">
            <h1>Hi, I'm <span class="name">Om Singh</span></h1>
            <p class="typewriter">I'm a <span id="typewriter-text"></span><span class="cursor">|</span></p>
            <p>Building innovative solutions with code and data</p>
            <div class="btn-group">
                <a href="#projects" class="btn btn-primary">View Projects</a>
                <a href="#contact" class="btn btn-outline">Contact Me</a>
            </div>
            <div class="social-links">
                <a href="https://www.linkedin.com/in/om-singh5" target="_blank"><i class="fab fa-linkedin"></i></a>
                <a href="https://github.com/Om-Singh-45" target="_blank"><i class="fab fa-github"></i></a>
                <a href="https://www.instagram.com/omsingh_45_45?igsh=MXB5M2g2MzN0anlyYw==" target="_blank"><i class="fab fa-instagram"></i></a>
            </div>
        </div>
    </section>

    <!-- About Section -->
    <section id="about" class="about">
        <h2 class="section-title">About Me</h2>
        <div class="container">
            <div class="image animate">
                <img src="images/om_image_mnali.jpg" alt="Om Singh">
            </div>
            <div class="text animate">
                <h3>Software Developer & Data Analyst</h3>
                <p>I'm Om Singh, a dedicated software developer and data analyst based in Mumbai, Maharashtra. My passion lies in crafting innovative, user-centric applications and uncovering actionable insights from data to solve real-world challenges.</p>
                <p>With a strong foundation in both frontend and backend development, I specialize in creating seamless, scalable web applications. My expertise in AI and machine learning allows me to integrate intelligent features that enhance user experiences and streamline processes.</p>
                <p>I thrive on continuous learning, embracing new technologies to deliver cutting-edge solutions. Whether it's building an AI-powered system or analyzing complex datasets, I approach every project with creativity, precision, and a commitment to excellence.</p>
                <div class="info-item">
                    <i class="fas fa-map-marker-alt"></i>
                    <span>Mumbai, Maharashtra, India</span>
                </div>
                <div class="info-item">
                    <i class="fas fa-phone"></i>
                    <span>8591224365</span>
                </div>
                <a href="#contact" class="btn btn-primary">Get In Touch</a>
            </div>
        </div>
    </section>

    <!-- Skills Section -->
    <section id="skills" class="skills">
        <h2 class="section-title">My Skills</h2>
        <div class="skills-galaxy-container">
            <canvas id="skillsGalaxy"></canvas>
            <div id="skillDetail" class="skill-detail-popup">
                <div class="skill-detail-content">
                    <h3 id="skillDetailTitle">Skill Name</h3>
                    <div class="skill-detail-level">
                        <div class="progress-container">
                            <div id="skillDetailProgress" class="progress-bar" data-width="85%"></div>
                        </div>
                    </div>
                    <p id="skillDetailDesc">Skill description goes here...</p>
                    <button id="closeSkillDetail" class="btn btn-primary">Close</button>
                </div>
            </div>
        </div>
    </section>

    <!-- Projects Section -->
    <section id="projects" class="projects">
        <h2 class="section-title">My Projects</h2>
        <div class="container">
            <div class="projects-grid">
                <div class="project-card animate">
                    <div class="project-image">
                        <img src="images/projects/movie_booking.png" alt="Movie Ticket Booking System">
                    </div>
                    <div class="project-content">
                        <h3 class="project-title">Movie Ticket Booking System using AI</h3>
                        <p class="project-description">An intelligent movie ticket booking system that integrates AI-powered chat features to simplify user interaction and enhance the ticket purchasing experience. Users can explore movies, showtimes, and book tickets seamlessly through a conversational interface.</p>
                        <div class="project-tech">
                            <span class="tech-badge">HTML</span>
                            <span class="tech-badge">CSS</span>
                            <span class="tech-badge">Python Flask</span>
                            <span class="tech-badge">MySQL</span>
                            <span class="tech-badge">AI Chatbot</span>
                        </div>
                        <div class="project-links">
                            <a href="https://github.com/Om-Singh-45/Movie-Ticket-Booking-Sysem.git" class="github-link"><i class="fab fa-github"></i> GitHub</a>
                        </div>
                    </div>
                </div>
                <div class="project-card animate">
                    <div class="project-image">
                        <img src="images/projects/text_to_image.png" alt="Text-to-Image Generator">
                    </div>
                    <div class="project-content">
                        <h3 class="project-title">Text-to-Image Generator</h3>
                        <p class="project-description">A powerful AI-based Text-to-Image Generator built using Google Colab and deep learning models. Converts text prompts into stunning AI-generated images with customizable parameters.</p>
                        <div class="project-tech">
                            <span class="tech-badge">Python</span>
                            <span class="tech-badge">Google Colab</span>
                            <span class="tech-badge">Deep Learning</span>
                            <span class="tech-badge">Neural Networks</span>
                            <span class="tech-badge">AI/ML</span>
                        </div>
                        <div class="project-links">
                            <a href="https://github.com/Om-Singh-45/Text-to-Image.git" class="github-link"><i class="fab fa-github"></i> GitHub</a>
                        </div>
                    </div>
                </div>
                <div class="project-card animate">
                    <div class="project-image">
                        <img src="images/projects/recipe_finder.png" alt="Food Recipe Suggestor">
                    </div>
                    <div class="project-content">
                        <h3 class="project-title">Food Recipe Suggestor using Ingredients</h3>
                        <p class="project-description">A smart machine learning-based system that suggests food recipes based on the ingredients you have at home. Users simply enter available ingredients, and the system recommends relevant recipes.</p>
                        <div class="project-tech">
                            <span class="tech-badge">HTML</span>
                            <span class="tech-badge">CSS</span>
                            <span class="tech-badge">Python Flask</span>
                            <span class="tech-badge">MySQL</span>
                            <span class="tech-badge">Machine Learning</span>
                        </div>
                        <div class="project-links">
                            <a href="https://github.com/Om-Singh-45/Food-Recipe-Suggestor.git" class="github-link"><i class="fab fa-github"></i> GitHub</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Contact Section -->
    <section id="contact" class="contact">
        <h2 class="section-title">Contact Me</h2>
        <div class="container">
            <div class="contact-info animate">
                <h3>Get In Touch</h3>
                <div class="contact-info-item">
                    <i class="fas fa-map-marker-alt"></i>
                    <div class="content">
                        <h4>Location</h4>
                        <p>Mumbai, Maharashtra, India</p>
                    </div>
                </div>
                <div class="contact-info-item">
                    <i class="fas fa-phone"></i>
                    <div class="content">
                        <h4>Phone</h4>
                        <p>8591224365</p>
                    </div>
                </div>
                <div class="contact-social">
                    <h4>Follow Me</h4>
                    <div class="contact-social-links">
                        <a href="https://www.linkedin.com/in/om-singh5" target="_blank"><i class="fab fa-linkedin"></i></a>
                        <a href="https://github.com/Om-Singh-45" target="_blank"><i class="fab fa-github"></i></a>
                        <a href="https://www.instagram.com/omsingh_45_45?igsh=MXB5M2g2MzN0anlyYw==" target="_blank"><i class="fab fa-instagram"></i></a>
                    </div>
                </div>
            </div>
            <div class="contact-form animate">
                <h3>Send a Message</h3>
                <form id="contact-form">
                    <div class="form-group">
                        <label for="name">Name</label>
                        <input type="text" id="name" class="form-control" required>
                    </div>
                    <div class="form-group">
                        <label for="email">Email</label>
                        <input type="email" id="email" class="form-control" required>
                    </div>
                    <div class="form-group">
                        <label for="message">Message</label>
                        <textarea id="message" class="form-control" required></textarea>
                    </div>
                    <button type="submit" class="form-btn">Send Message</button>
                </form>
            </div>
        </div>
    </section>

    <!-- Floating contact button -->
    <div class="floating-contact" id="floating-contact">
        <div class="floating-icon">
            <i class="fas fa-comments"></i>
        </div>
        <div class="floating-text">Let's Talk!</div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>Let's create something amazing together!</p>
            <div class="social-links">
                <a href="https://www.linkedin.com/in/om-singh5" target="_blank"><i class="fab fa-linkedin"></i></a>
                <a href="https://github.com/Om-Singh-45" target="_blank"><i class="fab fa-github"></i></a>
                <a href="https://www.instagram.com/omsingh_45_45?igsh=MXB5M2g2MzN0anlyYw==" target="_blank"><i class="fab fa-instagram"></i></a>
            </div>
            <p class="copyright">Â© 2025 Om Singh. All Rights Reserved.</p>
        </div>
    </footer>

    <!-- Scroll to Top -->
    <div class="scroll-top">
        <i class="fas fa-chevron-up"></i>
    </div>

    <script>
        // Create cosmic background elements
        function createCosmicBackground() {
            const starsContainer = document.getElementById('starsContainer');
            const fallingStarsContainer = document.getElementById('fallingStarsContainer');
            const planetsContainer = document.getElementById('planetsContainer');
            const spaceshipContainer = document.getElementById('spaceshipContainer');
            const isMobile = window.innerWidth <= 768;
            const numberOfStars = isMobile ? 50 : 100;
            const numberOfPlanets = 2;
            const numberOfFallingStars = isMobile ? 2 : 5;

            // Clear containers
            starsContainer.innerHTML = '';
            fallingStarsContainer.innerHTML = '';
            planetsContainer.innerHTML = '';
            spaceshipContainer.innerHTML = '';

            const fragmentStars = document.createDocumentFragment();
            const fragmentFallingStars = document.createDocumentFragment();
            const fragmentPlanets = document.createDocumentFragment();
            const fragmentSpaceship = document.createDocumentFragment();

            // Create twinkling stars
            for (let i = 0; i < numberOfStars; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.animationDelay = `${Math.random() * 2}s`;
                fragmentStars.appendChild(star);
            }

            // Create falling stars
            for (let i = 0; i < numberOfFallingStars; i++) {
                const fallingStar = document.createElement('div');
                fallingStar.classList.add('falling-star');
                fallingStar.style.left = `${Math.random() * 100}%`;
                fallingStar.style.animationDelay = `${Math.random() * 5}s`;
                fragmentFallingStars.appendChild(fallingStar);
            }

            // Create planets
            const planetSizes = ['small', 'medium'];
            const planetPositions = [
                { left: '10%', top: '20%' },
                { left: '80%', top: '70%' }
            ];

            for (let i = 0; i < numberOfPlanets; i++) {
                const planet = document.createElement('div');
                planet.classList.add('planet', planetSizes[i]);
                if (i === 0) planet.classList.add('ring');
                planet.style.left = planetPositions[i].left;
                planet.style.top = planetPositions[i].top;
                planet.style.animationDelay = `${Math.random() * 10}s`;
                fragmentPlanets.appendChild(planet);
            }

            // Create single spaceship
            const spaceship = document.createElement('div');
            spaceship.classList.add('spaceship');
            spaceship.style.left = '0%';
            spaceship.style.top = '0%';
            fragmentSpaceship.appendChild(spaceship);

            starsContainer.appendChild(fragmentStars);
            fallingStarsContainer.appendChild(fragmentFallingStars);
            planetsContainer.appendChild(fragmentPlanets);
            spaceshipContainer.appendChild(fragmentSpaceship);
        }

        // Typewriter effect
        function typewriterEffect() {
            const texts = [
                "Software Developer",
                "Data Analyst",
                "AI Enthusiast",
                "Problem Solver"
            ];
            
            let textIndex = 0;
            let charIndex = 0;
            let isDeleting = false;
            const typeSpeed = 100; // Speed of typing
            const deleteSpeed = 50; // Speed of deleting
            const waitAfterTyping = 1500; // Time to wait after full text is displayed
            
            const typewriter = document.getElementById('typewriter-text');
            
            function type() {
                const currentText = texts[textIndex];
                
                if (isDeleting) {
                    // Removing text
                    typewriter.textContent = currentText.substring(0, charIndex - 1);
                    charIndex--;
                } else {
                    // Adding text
                    typewriter.textContent = currentText.substring(0, charIndex + 1);
                    charIndex++;
                }
                
                // Set typing speed
                let typingSpeed = isDeleting ? deleteSpeed : typeSpeed;
                
                // If completed typing current text
                if (!isDeleting && charIndex === currentText.length) {
                    typingSpeed = waitAfterTyping;
                    isDeleting = true;
                } else if (isDeleting && charIndex === 0) {
                    isDeleting = false;
                    textIndex = (textIndex + 1) % texts.length;
                }
                
                setTimeout(type, typingSpeed);
            }
            
            // Start the typing effect
            setTimeout(type, 1000);
        }
        
        // Animate skill bars when in viewport
        function animateSkillBars() {
            const progressBars = document.querySelectorAll('.progress-bar');
            
            function setSkillBarWidths() {
                progressBars.forEach(bar => {
                    const width = bar.getAttribute('data-width');
                    bar.style.width = width;
                });
            }
            
            const skillsObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        setTimeout(setSkillBarWidths, 200);
                        skillsObserver.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.5 });
            
            // Observe the skills section
            const skillsSection = document.querySelector('#skills');
            if (skillsSection) {
                skillsObserver.observe(skillsSection);
            }
        }
        
        // Fade-in animation for elements
        function setupFadeInAnimations() {
            const fadeElements = document.querySelectorAll('.fade-in');
            
            const fadeObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1 });
            
            fadeElements.forEach(el => fadeObserver.observe(el));
        }

        // Navbar Scroll Effect
        window.addEventListener('scroll', () => {
            const navbar = document.querySelector('.navbar');
            navbar.classList.toggle('scrolled', window.scrollY > 50);

            // Update spaceship position on scroll
            const spaceship = document.querySelector('.spaceship');
            if (spaceship) {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const newX = Math.random() * (viewportWidth - 80);
                const newY = Math.random() * (viewportHeight - 80);
                spaceship.style.transform = `translate(${newX}px, ${newY}px)`;
            }
        });

        // Mobile Menu Toggle
        const openMenu = document.getElementById('open-menu');
        const closeMenu = document.getElementById('close-menu');
        const menu = document.getElementById('menu');

        openMenu.addEventListener('click', () => menu.classList.add('active'));
        closeMenu.addEventListener('click', () => menu.classList.remove('active'));

        // Scroll to Top Button
        const scrollTop = document.querySelector('.scroll-top');
        window.addEventListener('scroll', () => {
            scrollTop.classList.toggle('show', window.scrollY > 300);
        });

        scrollTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Smooth Scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    if (menu.classList.contains('active')) {
                        menu.classList.remove('active');
                    }
                    window.scrollTo({
                        top: targetElement.offsetTop - 60,
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Animation on Scroll
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('animate');
                }
            });
        }, { threshold: 0.2 });

        document.querySelectorAll('.animate').forEach(el => observer.observe(el));

        // Form Submission
        document.getElementById('contact-form').addEventListener('submit', (e) => {
            e.preventDefault();
            alert('Message sent! (Demo - requires backend integration)');
            e.target.reset();
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            createCosmicBackground();
            typewriterEffect();
            animateSkillBars();
            setupFadeInAnimations();
            
            // Initialize Skills Galaxy
            const skillsGalaxy = new SkillsGalaxy();
            
            // Add fade-in class to project cards
            document.querySelectorAll('.project-card').forEach(card => {
                card.classList.add('fade-in');
            });
            
            // Particle.js configuration
            particlesJS("particles-js", {
                "particles": {
                    "number": {
                        "value": 80,
                        "density": {
                            "enable": true,
                            "value_area": 800
                        }
                    },
                    "color": {
                        "value": "#ffffff"
                    },
                    "shape": {
                        "type": "circle",
                        "stroke": {
                            "width": 0,
                            "color": "#000000"
                        }
                    },
                    "opacity": {
                        "value": 0.5,
                        "random": true
                    },
                    "size": {
                        "value": 3,
                        "random": true
                    },
                    "line_linked": {
                        "enable": true,
                        "distance": 150,
                        "color": "#2563eb",
                        "opacity": 0.4,
                        "width": 1
                    },
                    "move": {
                        "enable": true,
                        "speed": 2,
                        "direction": "none",
                        "random": true,
                        "straight": false,
                        "out_mode": "out",
                        "bounce": false
                    }
                },
                "interactivity": {
                    "detect_on": "canvas",
                    "events": {
                        "onhover": {
                            "enable": true,
                            "mode": "grab"
                        },
                        "onclick": {
                            "enable": true,
                            "mode": "push"
                        },
                        "resize": true
                    },
                    "modes": {
                        "grab": {
                            "distance": 140,
                            "line_linked": {
                                "opacity": 1
                            }
                        },
                        "push": {
                            "particles_nb": 4
                        }
                    }
                },
                "retina_detect": true
            });

            // Custom cursor
            setupCustomCursor();
            setupFloatingContact();
        });

        // Recreate cosmic elements on resize
        window.addEventListener('resize', () => {
            createCosmicBackground();
        });

        // Custom cursor
        function setupCustomCursor() {
            const cursorDot = document.getElementById('cursor-dot');
            const cursorOutline = document.getElementById('cursor-outline');
            
            document.addEventListener('mousemove', (e) => {
                // Show cursors if they're hidden
                if (cursorDot.style.opacity !== '1') {
                    cursorDot.style.opacity = '1';
                    cursorOutline.style.opacity = '1';
                }
                
                // Position the dot cursor exactly at the mouse position
                cursorDot.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`;
                
                // Position the outline cursor with slight delay for smooth effect
                setTimeout(() => {
                    cursorOutline.style.transform = `translate(${e.clientX - 15}px, ${e.clientY - 15}px)`;
                }, 50);
            });
            
            // Scale up outline on hover over clickable elements
            document.querySelectorAll('a, button, .btn, .project-card, .skill-item, input, textarea').forEach(el => {
                el.addEventListener('mouseenter', () => {
                    cursorOutline.style.transform = 'translate(calc(-50% + ' + event.clientX + 'px), calc(-50% + ' + event.clientY + 'px)) scale(1.5)';
                    cursorOutline.style.borderColor = 'var(--accent-color)';
                    cursorDot.style.backgroundColor = 'var(--accent-color)';
                });
                
                el.addEventListener('mouseleave', () => {
                    cursorOutline.style.transform = 'translate(calc(-50% + ' + event.clientX + 'px), calc(-50% + ' + event.clientY + 'px)) scale(1)';
                    cursorOutline.style.borderColor = 'var(--primary-color)';
                    cursorDot.style.backgroundColor = 'var(--primary-color)';
                });
            });
            
            // Hide cursor when leaving the window
            document.addEventListener('mouseout', (e) => {
                if (e.relatedTarget === null) {
                    cursorDot.style.opacity = '0';
                    cursorOutline.style.opacity = '0';
                }
            });
        }

        // 3D tilt effect for project cards
        function setupTiltEffect() {
            const cards = document.querySelectorAll('.project-card');
            
            cards.forEach(card => {
                card.addEventListener('mousemove', (e) => {
                    const rect = card.getBoundingClientRect();
                    const x = e.clientX - rect.left; // x position within the card
                    const y = e.clientY - rect.top; // y position within the card
                    
                    const xRotation = 20 * ((y - rect.height / 2) / rect.height);
                    const yRotation = -20 * ((x - rect.width / 2) / rect.width);
                    
                    card.style.transform = `perspective(1000px) rotateX(${xRotation}deg) rotateY(${yRotation}deg) scale3d(1.05, 1.05, 1.05)`;
                });
                
                card.addEventListener('mouseout', () => {
                    card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)';
                });
            });
        }

        // Floating contact button
        function setupFloatingContact() {
            const floatingContact = document.getElementById('floating-contact');
            const contactSection = document.getElementById('contact');
            
            floatingContact.addEventListener('click', () => {
                contactSection.scrollIntoView({ behavior: 'smooth' });
            });
        }

        // Skills Galaxy
        class SkillsGalaxy {
            constructor() {
                this.canvas = document.getElementById('skillsGalaxy');
                this.ctx = this.canvas.getContext('2d');
                this.skills = [
                    { name: 'React.js', level: 85, type: 'Frontend', description: 'Building interactive and responsive UI components with React hooks and state management.', color: '#61DAFB', radius: 25 },
                    { name: 'HTML5/CSS3', level: 92, type: 'Frontend', description: 'Creating semantic and accessible web layouts with modern CSS techniques.', color: '#E44D26', radius: 28 },
                    { name: 'JavaScript', level: 88, type: 'Languages', description: 'Implementing complex client-side logic and interactive web features.', color: '#F7DF1E', radius: 27 },
                    { name: 'Tailwind CSS', level: 80, type: 'Frontend', description: 'Building responsive designs quickly with utility-first approach.', color: '#38B2AC', radius: 22 },
                    { name: 'Node.js', level: 75, type: 'Backend', description: 'Creating scalable server-side applications and APIs.', color: '#68A063', radius: 23 },
                    { name: 'Express.js', level: 78, type: 'Backend', description: 'Building robust backend services and RESTful APIs.', color: '#000000', radius: 24 },
                    { name: 'MongoDB', level: 82, type: 'Database', description: 'Working with NoSQL databases for flexible data models.', color: '#47A248', radius: 25 },
                    { name: 'MySQL', level: 75, type: 'Database', description: 'Designing and optimizing relational database schemas.', color: '#4479A1', radius: 22 },
                    { name: 'Python', level: 90, type: 'Languages', description: 'Developing data analysis and machine learning applications.', color: '#3776AB', radius: 30 },
                    { name: 'C++', level: 85, type: 'Languages', description: 'Building high-performance applications and algorithms.', color: '#00599C', radius: 26 }
                ];
                
                this.centerX = 0;
                this.centerY = 0;
                this.orbits = [];
                this.currentZoomLevel = 1;
                this.targetZoomLevel = 1;
                this.selectedSkill = null;
                this.animationFrameId = null;
                this.mouseX = 0;
                this.mouseY = 0;
                
                this.skillDetailPopup = document.getElementById('skillDetail');
                this.skillDetailTitle = document.getElementById('skillDetailTitle');
                this.skillDetailProgress = document.getElementById('skillDetailProgress');
                this.skillDetailDesc = document.getElementById('skillDetailDesc');
                this.closeDetailBtn = document.getElementById('closeSkillDetail');
                
                this.closeDetailBtn.addEventListener('click', () => this.hideSkillDetail());
                
                // Set up event listeners
                this.canvas.addEventListener('click', this.handleClick.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                window.addEventListener('resize', this.handleResize.bind(this));
                
                this.handleResize();
                this.setupOrbits();
                this.animate();
            }
            
            handleResize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                
                // Recalculate orbits when resizing
                this.setupOrbits();
            }
            
            setupOrbits() {
                // Create precise orbital system with evenly spaced planets
                this.orbits = [];
                
                // Calculate canvas dimensions and center
                const width = this.canvas.width;
                const height = this.canvas.height;
                this.centerX = width / 2;
                this.centerY = height / 2;
                
                // Calculate the visible area's size - use more of the available space
                const maxRadius = Math.min(width, height) * 0.42; // Increased from 0.38 to use more space
                
                // Define organized orbital rings with proper spacing
                // Each ring has distinct radius and planets are evenly spaced around the ring
                const orbitalRings = [
                    { radius: maxRadius * 0.35, count: 3 }, // Inner ring
                    { radius: maxRadius * 0.65, count: 3 }, // Middle ring
                    { radius: maxRadius * 0.95, count: 4 }  // Outer ring
                ];
                
                // Assign skills to each ring
                const skillAssignments = [
                    // Inner ring (faster planets)
                    ['JavaScript', 'Express.js', 'Tailwind CSS'],
                    // Middle ring
                    ['React.js', 'Node.js', 'HTML5/CSS3'],
                    // Outer ring (slower planets)
                    ['Python', 'MongoDB', 'MySQL', 'C++']
                ];
                
                // Create orbits with precise positioning
                orbitalRings.forEach((ring, ringIndex) => {
                    const skills = skillAssignments[ringIndex];
                    
                    // For each skill in this ring
                    skills.forEach((skillName, skillIndex) => {
                        // Find matching skill object
                        const skill = this.skills.find(s => s.name === skillName);
                        
                        if (skill) {
                            // Calculate precise angle for even distribution
                            const angleStep = (2 * Math.PI) / skills.length;
                            const baseAngle = angleStep * skillIndex;
                            
                            // Add tiny random offset for natural feel (-5 to +5 degrees in radians)
                            const angleOffset = (Math.random() * 0.17) - 0.085;
                            const angle = baseAngle + angleOffset;
                            
                            // Slightly vary orbit radius to avoid perfect circles
                            const radiusVariation = 1 + ((Math.random() * 0.08) - 0.04); // Â±4% variation
                            const orbitRadius = ring.radius * radiusVariation;
                            
                            // Orbit eccentricity (elliptical orbits)
                            // Inner orbits more circular, outer more elliptical
                            const eccentricity = 0.02 + (ringIndex * 0.02);
                            
                            // Calculate speed based on ring - inner planets move faster (inverse to radius)
                            const baseSpeed = 0.0008; // Increased speed
                            const speedFactor = 1 - (ringIndex * 0.2); // Reduce speed for outer rings
                            const speed = baseSpeed * speedFactor;
                            
                            this.orbits.push({
                                skill,
                                orbitRadius,
                                angle,
                                speed,
                                eccentricity,
                                tiltX: Math.random() * 0.1,
                                tiltY: Math.random() * 0.1,
                                phaseShift: angle, // Start at distributed position
                                x: 0,
                                y: 0, 
                                z: 0,
                                ringIndex, // Store ring index for drawing orbit paths
                                hovered: false,
                                pulseAmount: 0,
                                pulseDirection: 1,
                                type: skill.type,
                                startTime: Date.now() + (skillIndex * 300) // Staggered start times
                            });
                        }
                    });
                });
                
                // Assign distinct orbit paths
                this.orbitalPaths = orbitalRings.map(ring => ({
                    radius: ring.radius,
                    visible: true
                }));
                
                // Calculate initial positions
                this.calculateInitialPositions();
            }
            
            calculateInitialPositions() {
                // Update all positions initially
                this.orbits.forEach(orbit => {
                    const a = orbit.orbitRadius;
                    const b = orbit.orbitRadius * (1 - orbit.eccentricity);
                    const theta = orbit.angle + orbit.phaseShift;
                    
                    // Basic elliptical orbit
                    const baseX = a * Math.cos(theta);
                    const baseY = b * Math.sin(theta);
                    
                    // Apply tilt for 3D effect
                    orbit.x = this.centerX + (baseX * Math.cos(orbit.tiltX) - baseY * Math.sin(orbit.tiltY));
                    orbit.y = this.centerY + (baseX * Math.sin(orbit.tiltX) + baseY * Math.cos(orbit.tiltY));
                    
                    // Calculate z-position for depth
                    orbit.z = Math.sin(theta) * 50;
                });
            }
            
            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Use a very transparent background to blend with cosmic background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.0)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background elements
                this.drawConstellations();
                this.drawStarTwinkles();
                
                // Draw orbit rings
                this.drawOrbitRings();
                
                // Sort orbits by z-index to create depth effect
                const sortedOrbits = [...this.orbits].sort((a, b) => a.z - b.z);
                
                // Draw connecting lines between skills to indicate relationships
                this.drawConnections(sortedOrbits);
                
                // Get current time for animation
                const currentTime = Date.now();
                
                // Update and draw skills
                sortedOrbits.forEach(orbit => {
                    // Calculate time-based animation with staggered starts
                    const elapsed = currentTime - orbit.startTime;
                    if (elapsed < 0) return; // Don't show yet if staggered start time hasn't arrived
                    
                    // Update angle - time-based animation for smooth rendering across devices
                    orbit.angle += orbit.speed;
                    
                    // Calculate 3D position using elliptical orbit equations
                    const a = orbit.orbitRadius;
                    const b = orbit.orbitRadius * (1 - orbit.eccentricity);
                    const theta = orbit.angle;
                    
                    // Basic elliptical orbit
                    const baseX = a * Math.cos(theta);
                    const baseY = b * Math.sin(theta);
                    
                    // Apply tilt for 3D effect
                    orbit.x = this.centerX + (baseX * Math.cos(orbit.tiltX) - baseY * Math.sin(orbit.tiltY));
                    orbit.y = this.centerY + (baseX * Math.sin(orbit.tiltX) + baseY * Math.cos(orbit.tiltY));
                    
                    // Calculate z-position for depth
                    orbit.z = Math.sin(theta) * 50;
                    
                    // Update pulse effect for hover animation
                    if (orbit.hovered) {
                        orbit.pulseAmount += 0.05 * orbit.pulseDirection;
                        if (orbit.pulseAmount > 1 || orbit.pulseAmount < 0) {
                            orbit.pulseDirection *= -1;
                        }
                    } else {
                        orbit.pulseAmount = Math.max(0, orbit.pulseAmount - 0.05);
                    }
                    
                    // Draw skills
                    this.drawSkill(orbit);
                });
                
                // Draw orbit trails when a planet is hovered
                sortedOrbits.forEach(orbit => {
                    if (orbit.hovered) {
                        this.drawOrbitTrail(orbit);
                    }
                });
                
                // Interactive effect - slight gravity pull toward mouse
                this.applyMouseGravity();
                
                // Draw center avatar last (on top)
                this.drawCenterAvatar();
                
                this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
            }
            
            drawOrbitTrail(orbit) {
                // Draw highlighted orbit path when planet is hovered
                this.ctx.save();
                
                const a = orbit.orbitRadius;
                const b = orbit.orbitRadius * (1 - orbit.eccentricity);
                
                // Draw full elliptical orbit
                this.ctx.beginPath();
                this.ctx.ellipse(
                    this.centerX, 
                    this.centerY, 
                    a, 
                    b,
                    0, // rotation
                    0, 
                    Math.PI * 2
                );
                
                // Use planet color for its orbit trail
                const gradient = this.ctx.createLinearGradient(
                    this.centerX - a, this.centerY,
                    this.centerX + a, this.centerY
                );
                gradient.addColorStop(0, `${orbit.skill.color}10`);
                gradient.addColorStop(0.5, `${orbit.skill.color}40`);
                gradient.addColorStop(1, `${orbit.skill.color}10`);
                
                this.ctx.strokeStyle = gradient;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            drawOrbitRings() {
                // Draw aesthetic orbit rings for each orbital path
                this.orbitalPaths.forEach(path => {
                    // Draw orbit ellipse
                    const radius = path.radius;
                    
                    // Use multiple arcs with varying opacity for a glowing effect
                    const maxGlow = 3;
                    for (let i = 0; i < maxGlow; i++) {
                        const opacity = 0.1 - (i * 0.03);
                        const width = 1 + (i * 0.5);
                        
                        this.ctx.beginPath();
                        this.ctx.ellipse(
                            this.centerX, 
                            this.centerY, 
                            radius, 
                            radius * 0.99, // Slight elliptical shape
                            0, // rotation
                            0, 
                            Math.PI * 2
                        );
                        this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                        this.ctx.lineWidth = width;
                        this.ctx.stroke();
                    }
                    
                    // Add ticks to the orbit ring for visual interest
                    for (let i = 0; i < 24; i++) {
                        const angle = (Math.PI * 2 / 24) * i;
                        const x1 = this.centerX + Math.cos(angle) * (radius - 1);
                        const y1 = this.centerY + Math.sin(angle) * (radius - 1);
                        const x2 = this.centerX + Math.cos(angle) * (radius + 1);
                        const y2 = this.centerY + Math.sin(angle) * (radius + 1);
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                        this.ctx.lineWidth = 0.5;
                        this.ctx.stroke();
                    }
                });
            }
            
            drawConstellations() {
                // Draw fixed constellation patterns
                this.ctx.save();
                
                const constellationPoints = [
                    // Define points for constellations - these are fixed points that don't move
                    // Constellation 1 - top left
                    [
                        {x: this.canvas.width * 0.1, y: this.canvas.height * 0.2},
                        {x: this.canvas.width * 0.2, y: this.canvas.height * 0.15},
                        {x: this.canvas.width * 0.25, y: this.canvas.height * 0.25},
                        {x: this.canvas.width * 0.15, y: this.canvas.height * 0.3},
                        {x: this.canvas.width * 0.1, y: this.canvas.height * 0.2}
                    ],
                    // Constellation 2 - top right
                    [
                        {x: this.canvas.width * 0.8, y: this.canvas.height * 0.2},
                        {x: this.canvas.width * 0.9, y: this.canvas.height * 0.1},
                        {x: this.canvas.width * 0.85, y: this.canvas.height * 0.3}
                    ],
                    // Constellation 3 - bottom right
                    [
                        {x: this.canvas.width * 0.7, y: this.canvas.height * 0.7},
                        {x: this.canvas.width * 0.8, y: this.canvas.height * 0.8},
                        {x: this.canvas.width * 0.9, y: this.canvas.height * 0.75},
                        {x: this.canvas.width * 0.85, y: this.canvas.height * 0.65},
                        {x: this.canvas.width * 0.7, y: this.canvas.height * 0.7}
                    ],
                    // Constellation 4 - bottom left
                    [
                        {x: this.canvas.width * 0.2, y: this.canvas.height * 0.7},
                        {x: this.canvas.width * 0.1, y: this.canvas.height * 0.8},
                        {x: this.canvas.width * 0.25, y: this.canvas.height * 0.9}
                    ]
                ];
                
                // Animate the constellations slightly for a living universe effect
                const time = Date.now() * 0.0005;
                
                // Draw each constellation
                constellationPoints.forEach((points, constellationIndex) => {
                    // Draw connecting lines with animated gradient
                    this.ctx.beginPath();
                    
                    // Apply subtle animation to the start point
                    const startX = points[0].x + Math.sin(time + constellationIndex) * 2;
                    const startY = points[0].y + Math.cos(time + constellationIndex) * 2;
                    this.ctx.moveTo(startX, startY);
                    
                    for (let i = 1; i < points.length; i++) {
                        // Apply subtle animation to each point
                        const x = points[i].x + Math.sin(time + i + constellationIndex) * 2;
                        const y = points[i].y + Math.cos(time + i + constellationIndex) * 2;
                        this.ctx.lineTo(x, y);
                    }
                    
                    // Animated opacity based on time
                    const opacity = 0.03 + Math.sin(time + constellationIndex) * 0.02;
                    
                    this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity + 0.05})`;
                    this.ctx.lineWidth = 0.5;
                    this.ctx.stroke();
                    
                    // Draw points with subtle animation
                    points.forEach((point, i) => {
                        // Animate point size based on time
                        const sizeOscillation = 0.5 + Math.sin(time * 2 + i + constellationIndex) * 0.5;
                        const pointSize = 1 + sizeOscillation * 0.5;
                        
                        // Animate point position
                        const x = point.x + Math.sin(time + i + constellationIndex) * 2;
                        const y = point.y + Math.cos(time + i + constellationIndex) * 2;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, pointSize, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.2 + sizeOscillation * 0.1})`;
                        this.ctx.fill();
                    });
                });
                
                this.ctx.restore();
            }
            
            drawStarTwinkles() {
                // Add more stars and make them twinkle naturally
                // Create more stars in random positions for space effect
                if (Math.random() < 0.4) {  // Increased probability for more stars
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const radius = 0.5 + Math.random() * 1.5;
                    
                    // Vary brightness for twinkling effect
                    const brightness = 0.3 + Math.random() * 0.7;
                    
                    this.ctx.save();
                    
                    // Add glow effect to some stars
                    if (Math.random() > 0.7) {
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                        this.ctx.shadowBlur = 5;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            drawConnections(orbits) {
                // Draw connections between skills with better organization
                this.ctx.save();
                
                // Group orbits by type for organized connections
                const orbitsByType = {};
                orbits.forEach(orbit => {
                    if (!orbitsByType[orbit.type]) {
                        orbitsByType[orbit.type] = [];
                    }
                    orbitsByType[orbit.type].push(orbit);
                });
                
                // Draw connections between skills of the same type
                Object.entries(orbitsByType).forEach(([type, typeOrbits]) => {
                    if (typeOrbits.length < 2) return;
                    
                    // Select type-specific color
                    let connectionColor;
                    switch(type) {
                        case 'Frontend':
                            connectionColor = '#38B2AC'; // Teal
                            break;
                        case 'Backend':
                            connectionColor = '#68A063'; // Green
                            break;
                        case 'Database':
                            connectionColor = '#4479A1'; // Blue
                            break;
                        case 'Languages':
                            connectionColor = '#F7DF1E'; // Yellow
                            break;
                        default:
                            connectionColor = '#FFFFFF'; // White
                    }
                    
                    // Connect orbits of the same type with a constellation-like pattern
                    for (let i = 0; i < typeOrbits.length; i++) {
                        for (let j = i + 1; j < typeOrbits.length; j++) {
                            const orbitA = typeOrbits[i];
                            const orbitB = typeOrbits[j];
                            
                            // Calculate distance
                            const dx = orbitA.x - orbitB.x;
                            const dy = orbitA.y - orbitB.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // Only connect if reasonably close
                            if (distance < 400) {
                                // Calculate opacity based on distance
                                const opacity = this.mapRange(distance, 100, 400, 0.15, 0.03);
                                
                                // Create gradient connection
                                const gradient = this.ctx.createLinearGradient(
                                    orbitA.x, orbitA.y, orbitB.x, orbitB.y
                                );
                                gradient.addColorStop(0, `${connectionColor}${Math.floor(opacity * 255).toString(16).padStart(2, '0')}`);
                                gradient.addColorStop(0.5, `${connectionColor}${Math.floor(opacity * 255 * 1.5).toString(16).padStart(2, '0')}`);
                                gradient.addColorStop(1, `${connectionColor}${Math.floor(opacity * 255).toString(16).padStart(2, '0')}`);
                                
                                // Draw the connection line
                                this.ctx.beginPath();
                                this.ctx.moveTo(orbitA.x, orbitA.y);
                                this.ctx.lineTo(orbitB.x, orbitB.y);
                                this.ctx.strokeStyle = gradient;
                                this.ctx.lineWidth = 1;
                                this.ctx.stroke();
                                
                                // Add a pulse effect along the connection line
                                this.drawConnectionPulse(orbitA, orbitB, connectionColor);
                            }
                        }
                    }
                });
                
                // Draw subtle links from center to each planet (gravitational influence)
                orbits.forEach(orbit => {
                    // Calculate distance from center
                    const distance = Math.sqrt(
                        Math.pow(orbit.x - this.centerX, 2) + 
                        Math.pow(orbit.y - this.centerY, 2)
                    );
                    
                    // Calculate opacity based on distance
                    const opacity = this.mapRange(distance, 50, 400, 0.1, 0.02);
                    
                    // Create gradient
                    const gradient = this.ctx.createLinearGradient(
                        this.centerX, this.centerY, orbit.x, orbit.y
                    );
                    gradient.addColorStop(0, `rgba(37, 99, 235, ${opacity * 1.5})`);
                    gradient.addColorStop(1, `rgba(37, 99, 235, 0)`);
                    
                    // Draw connection
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.centerX, this.centerY);
                    this.ctx.lineTo(orbit.x, orbit.y);
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = 0.5;
                    this.ctx.stroke();
                });
                
                this.ctx.restore();
            }
            
            drawConnectionPulse(orbitA, orbitB, color) {
                // Create pulsing particle effect along connection lines
                const time = Date.now() * 0.001;
                const dx = orbitB.x - orbitA.x;
                const dy = orbitB.y - orbitA.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only draw pulse for connections below a certain threshold
                if (distance > 300) return;
                
                // Number of pulses based on distance
                const pulseCount = Math.floor(distance / 100) + 1;
                
                for (let i = 0; i < pulseCount; i++) {
                    // Calculate position along the line
                    const progress = (((time * (i + 1)) % 2) / 2);
                    const x = orbitA.x + dx * progress;
                    const y = orbitA.y + dy * progress;
                    
                    // Pulse size oscillates
                    const size = 1.5 + Math.sin(time * 3 + i) * 1;
                    
                    // Draw pulse
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fillStyle = `${color}40`;
                    this.ctx.fill();
                }
            }
            
            drawCenterAvatar() {
                this.ctx.save();
                
                // Enhanced glow effect
                this.ctx.shadowColor = 'rgba(37, 99, 235, 0.8)';
                this.ctx.shadowBlur = 30;
                
                // Central avatar radius - slightly larger than planets
                const avatarRadius = 50;
                
                // Draw radial rays/corona
                this.drawSunCorona(avatarRadius);
                
                // Draw orbit clock ticks
                this.drawClockTicks(avatarRadius);
                
                // Draw main sun gradient with enhanced colors
                const sunGradient = this.ctx.createRadialGradient(
                    this.centerX, this.centerY, 0,
                    this.centerX, this.centerY, avatarRadius
                );
                sunGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                sunGradient.addColorStop(0.2, 'rgba(79, 70, 229, 0.9)');
                sunGradient.addColorStop(0.7, 'rgba(37, 99, 235, 0.7)');
                sunGradient.addColorStop(1, 'rgba(37, 99, 235, 0.3)');
                
                // Draw main circle
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, avatarRadius, 0, Math.PI * 2);
                this.ctx.fillStyle = sunGradient;
                this.ctx.fill();
                
                // Add pulsing surface details
                this.drawSunSurfaceDetails(avatarRadius);
                
                // Add text with better styling
                this.drawCentralText();
                
                this.ctx.restore();
            }
            
            drawSunCorona(radius) {
                // Create sun corona/rays effect
                const rays = 16;
                const maxRayLength = radius * 0.4;
                
                for (let i = 0; i < rays; i++) {
                    const angle = (Math.PI * 2 / rays) * i;
                    const rayLength = radius + (maxRayLength * (0.5 + Math.sin(Date.now() * 0.001 + i) * 0.5));
                    
                    const x1 = this.centerX + Math.cos(angle) * radius;
                    const y1 = this.centerY + Math.sin(angle) * radius;
                    const x2 = this.centerX + Math.cos(angle) * rayLength;
                    const y2 = this.centerY + Math.sin(angle) * rayLength;
                    
                    const gradient = this.ctx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, 'rgba(79, 70, 229, 0.7)');
                    gradient.addColorStop(1, 'rgba(37, 99, 235, 0)');
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            }
            
            drawClockTicks(radius) {
                // Draw orbit clock ticks around the central sun
                const clockRadius = radius * 1.3;
                
                for (let i = 0; i < 24; i++) {
                    const angle = (Math.PI * 2 / 24) * i;
                    const innerRadius = clockRadius - (i % 6 === 0 ? 8 : 4);
                    const outerRadius = clockRadius;
                    
                    const x1 = this.centerX + Math.cos(angle) * innerRadius;
                    const y1 = this.centerY + Math.sin(angle) * innerRadius;
                    const x2 = this.centerX + Math.cos(angle) * outerRadius;
                    const y2 = this.centerY + Math.sin(angle) * outerRadius;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, ' + (i % 6 === 0 ? 0.5 : 0.3) + ')';
                    this.ctx.lineWidth = i % 6 === 0 ? 2 : 1;
                    this.ctx.stroke();
                }
            }
            
            drawSunSurfaceDetails(radius) {
                // Create animated solar surface details
                const time = Date.now() * 0.001;
                const numDetails = 15;
                
                for (let i = 0; i < numDetails; i++) {
                    const detailAngle = Math.PI * 2 * (i / numDetails);
                    const dist = (0.2 + Math.sin(time + i) * 0.2) * radius;
                    
                    const detailX = this.centerX + Math.cos(detailAngle) * dist;
                    const detailY = this.centerY + Math.sin(detailAngle) * dist;
                    const detailSize = 3 + Math.sin(time * 2 + i) * 2;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(detailX, detailY, detailSize, 0, Math.PI * 2);
                    
                    const brightness = 0.7 + Math.sin(time + i * 2) * 0.3;
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                    this.ctx.fill();
                }
            }
            
            drawCentralText() {
                // Draw central text with professional styling
                this.ctx.fillStyle = '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Draw 'Om' text
                this.ctx.font = 'bold 18px "Segoe UI", sans-serif';
                this.ctx.fillText('Om', this.centerX, this.centerY - 10);
                
                // Draw 'Singh' text
                this.ctx.font = 'bold 16px "Segoe UI", sans-serif';
                this.ctx.fillText('Singh', this.centerX, this.centerY + 12);
            }
            
            drawSkill(orbit) {
                const { skill, x, y, z, hovered, pulseAmount } = orbit;
                
                // Scale based on z-position for depth effect
                const zScale = this.mapRange(z, -50, 50, 0.7, 1.3);
                
                // Additional scale for hover and pulse effects
                const hoverScale = 1 + (pulseAmount * 0.3);
                
                // Final radius with all effects
                const radius = skill.radius * zScale * hoverScale;
                
                this.ctx.save();
                
                // Enhanced glow effect based on hover state and z-position
                if (hovered || z > 0) {
                    const glowAmount = hovered ? 20 + (pulseAmount * 10) : (z / 50) * 15;
                    this.ctx.shadowColor = skill.color;
                    this.ctx.shadowBlur = glowAmount;
                }
                
                // Draw orbit trail behind skill when hovered
                if (hovered) {
                    // The orbit trail is now drawn in a separate method
                    // to ensure proper layering with other elements
                }
                
                // Draw planet atmosphere/glow
                const atmosphereSize = radius * 1.15;
                const gradient = this.ctx.createRadialGradient(
                    x, y, radius * 0.8,
                    x, y, atmosphereSize
                );
                gradient.addColorStop(0, `${skill.color}50`);
                gradient.addColorStop(1, `${skill.color}00`);
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, atmosphereSize, 0, Math.PI * 2);
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                // Draw main planet body
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                
                // Create complex gradient for planets with light source
                const planetGradient = this.ctx.createRadialGradient(
                    x - radius * 0.3, y - radius * 0.3, radius * 0.1, // Light source
                    x, y, radius
                );
                
                // Use skill color with variations for more realistic planet appearance
                planetGradient.addColorStop(0, this.lightenColor(skill.color, 70));
                planetGradient.addColorStop(0.4, skill.color);
                planetGradient.addColorStop(1, this.darkenColor(skill.color, 30));
                
                this.ctx.fillStyle = planetGradient;
                this.ctx.fill();
                
                // Add planetary details based on skill type
                this.addPlanetaryDetails(x, y, radius, skill);
                
                // Draw semi-transparent atmosphere/ring effect
                if (radius > 20 && !hovered) {
                    this.drawPlanetaryRing(x, y, radius, skill);
                }
                
                // Draw border - thicker when hovered
                this.ctx.strokeStyle = hovered ? 
                    'rgba(255, 255, 255, 0.8)' : 
                    'rgba(255, 255, 255, 0.2)';
                this.ctx.lineWidth = hovered ? 2 : 0.8;
                this.ctx.stroke();
                
                // Draw skill name with dynamic sizing and better contrast
                const fontSize = Math.max(11, Math.min(14, radius * 0.5));
                const textColor = this.getContrastColor(skill.color);
                
                // Clear a small area for text if needed for legibility
                if (!hovered) {
                    this.ctx.fillStyle = `${skill.color}99`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius * 0.6, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Draw skill name
                this.ctx.fillStyle = textColor;
                this.ctx.font = `${hovered ? 'bold' : ''} ${fontSize}px 'Segoe UI', sans-serif`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Add text shadow for better readability
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                this.ctx.shadowBlur = 4;
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 0;
                
                this.ctx.fillText(skill.name, x, y);
                
                // Add skill level indicator when hovered
                if (hovered) {
                    this.drawSkillLevel(x, y, radius, skill);
                }
                
                this.ctx.restore();
            }
            
            addPlanetaryDetails(x, y, radius, skill) {
                // Add different types of surface details based on skill type
                
                // Skip for very small planets
                if (radius < 10) return;
                
                this.ctx.save();
                
                // Different patterns based on skill type
                switch (skill.type) {
                    case 'Frontend':
                        // Create grid/web-like pattern
                        this.drawGridPattern(x, y, radius);
                        break;
                        
                    case 'Backend':
                        // Create server-like structures
                        this.drawBlockPattern(x, y, radius);
                        break;
                        
                    case 'Database':
                        // Create circular patterns like data clusters
                        this.drawDatabasePattern(x, y, radius);
                        break;
                        
                    case 'Languages':
                    default:
                        // Create crater-like patterns
                        this.drawCraterPattern(x, y, radius);
                        break;
                }
                
                this.ctx.restore();
            }
            
            drawGridPattern(x, y, radius) {
                // Simple grid pattern for frontend skills
                const numLines = Math.floor(radius / 5);
                const spacing = radius * 1.5 / numLines;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                this.ctx.lineWidth = 0.5;
                
                // Draw horizontal grid lines
                for (let i = -numLines; i <= numLines; i++) {
                    const yOffset = i * spacing;
                    if (Math.abs(yOffset) > radius) continue;
                    
                    const width = Math.sqrt(radius * radius - yOffset * yOffset) * 1.8;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - width, y + yOffset);
                    this.ctx.lineTo(x + width, y + yOffset);
                    this.ctx.stroke();
                }
                
                // Draw vertical grid lines
                for (let i = -numLines; i <= numLines; i++) {
                    const xOffset = i * spacing;
                    if (Math.abs(xOffset) > radius) continue;
                    
                    const height = Math.sqrt(radius * radius - xOffset * xOffset) * 1.8;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + xOffset, y - height);
                    this.ctx.lineTo(x + xOffset, y + height);
                    this.ctx.stroke();
                }
            }
            
            drawBlockPattern(x, y, radius) {
                // Server rack-like pattern for backend skills
                const numBlocks = Math.floor(radius / 4);
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                
                for (let i = 0; i < numBlocks; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius * 0.7;
                    
                    const blockX = x + Math.cos(angle) * distance;
                    const blockY = y + Math.sin(angle) * distance;
                    
                    const width = 2 + Math.random() * 4;
                    const height = 2 + Math.random() * 4;
                    
                    this.ctx.fillRect(
                        blockX - width/2, 
                        blockY - height/2, 
                        width, 
                        height
                    );
                }
            }
            
            drawDatabasePattern(x, y, radius) {
                // Circular data patterns for database skills
                const numCircles = Math.floor(radius / 3);
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                this.ctx.lineWidth = 0.5;
                
                for (let i = 0; i < numCircles; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius * 0.7;
                    
                    const circleX = x + Math.cos(angle) * distance;
                    const circleY = y + Math.sin(angle) * distance;
                    
                    const circleRadius = 1 + Math.random() * 3;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(circleX, circleY, circleRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Sometimes fill the circle
                    if (Math.random() > 0.5) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        this.ctx.fill();
                    }
                }
            }
            
            drawCraterPattern(x, y, radius) {
                // Crater-like patterns for language skills
                const numCraters = Math.floor(radius / 2.5);
                
                for (let i = 0; i < numCraters; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius * 0.7;
                    
                    const craterX = x + Math.cos(angle) * distance;
                    const craterY = y + Math.sin(angle) * distance;
                    
                    const craterRadius = 1 + Math.random() * 3;
                    
                    // Draw crater with subtle gradient
                    const gradient = this.ctx.createRadialGradient(
                        craterX, craterY, 0,
                        craterX, craterY, craterRadius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(craterX, craterY, craterRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            drawPlanetaryRing(x, y, radius, skill) {
                // Draw an optional ring around some planets
                // Only add rings to randomly selected planets
                if (skill.name === 'MongoDB' || skill.name === 'Python' || skill.name === 'React.js') {
                    const ringWidth = radius * 0.6;
                    const ringInnerRadius = radius * 1.2;
                    const ringOuterRadius = ringInnerRadius + ringWidth;
                    
                    // Create ring gradient
                    const ringGradient = this.ctx.createRadialGradient(
                        x, y, ringInnerRadius,
                        x, y, ringOuterRadius
                    );
                    ringGradient.addColorStop(0, `${skill.color}30`);
                    ringGradient.addColorStop(0.5, `${skill.color}20`);
                    ringGradient.addColorStop(1, `${skill.color}00`);
                    
                    // Draw elliptical ring at an angle
                    this.ctx.save();
                    this.ctx.translate(x, y);
                    this.ctx.rotate(Math.PI / 6); // Tilt the ring
                    this.ctx.scale(1, 0.3); // Flatten to create perspective
                    
                    // Outer ring
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, ringOuterRadius, 0, Math.PI * 2);
                    this.ctx.fillStyle = ringGradient;
                    this.ctx.fill();
                    
                    // Clear inner part
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, ringInnerRadius, 0, Math.PI * 2);
                    this.ctx.globalCompositeOperation = 'destination-out';
                    this.ctx.fill();
                    this.ctx.globalCompositeOperation = 'source-over';
                    
                    this.ctx.restore();
                }
            }
            
            drawSkillLevel(x, y, radius, skill) {
                // Draw skill level indicator around the planet when hovered
                const levelRadius = radius * 1.4;
                
                this.ctx.save();
                
                // Background ring
                this.ctx.beginPath();
                this.ctx.arc(x, y, levelRadius, 0, Math.PI * 2);
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Skill level arc
                const levelAngle = (skill.level / 100) * Math.PI * 2;
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, levelRadius, -Math.PI/2, -Math.PI/2 + levelAngle);
                
                const gradient = this.ctx.createLinearGradient(
                    x - levelRadius, y,
                    x + levelRadius, y
                );
                gradient.addColorStop(0, this.lightenColor(skill.color, 30));
                gradient.addColorStop(1, skill.color);
                
                this.ctx.strokeStyle = gradient;
                this.ctx.lineWidth = 4;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();
                
                // Draw percentage text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '12px "Segoe UI", sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(`${skill.level}%`, x, y - levelRadius - 15);
                
                this.ctx.restore();
            }
            
            lightenColor(color, amount) {
                return this.adjustColor(color, amount);
            }
            
            darkenColor(color, amount) {
                return this.adjustColor(color, -amount);
            }
            
            getContrastColor(hexColor) {
                // Convert hex to RGB
                const r = parseInt(hexColor.slice(1, 3), 16);
                const g = parseInt(hexColor.slice(3, 5), 16);
                const b = parseInt(hexColor.slice(5, 7), 16);
                
                // Calculate luminance (perceived brightness)
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                // Return white or black based on background luminance
                return luminance > 0.5 ? '#000000' : '#ffffff';
            }
            
            mapRange(value, low1, high1, low2, high2) {
                return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
            }
            
            handleClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                // Check if center avatar was clicked
                const distToCenter = Math.sqrt(
                    Math.pow(mouseX - this.centerX, 2) + 
                    Math.pow(mouseY - this.centerY, 2)
                );
                
                if (distToCenter < 45) {
                    // Show all skills details or some special animation
                    this.pulseAllSkills();
                    return;
                }
                
                // Check if any skill was clicked
                for (const orbit of this.orbits) {
                    const dx = mouseX - orbit.x;
                    const dy = mouseY - orbit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Scale clickable area with planet size and z position
                    const zScale = this.mapRange(orbit.z, -50, 50, 0.7, 1.3);
                    const clickRadius = orbit.skill.radius * zScale * 1.2;
                    
                    if (distance < clickRadius) {
                        // Skill was clicked
                        this.showSkillDetail(orbit.skill);
                        return;
                    }
                }
                
                // If no skill was clicked and a detail popup is shown, hide it
                if (this.skillDetailPopup.classList.contains('active')) {
                    this.hideSkillDetail();
                }
            }
            
            pulseAllSkills() {
                // Create a wave effect emanating from center
                let delay = 0;
                
                this.orbits.sort((a, b) => {
                    const distA = Math.sqrt(Math.pow(a.x - this.centerX, 2) + Math.pow(a.y - this.centerY, 2));
                    const distB = Math.sqrt(Math.pow(b.x - this.centerX, 2) + Math.pow(b.y - this.centerY, 2));
                    return distA - distB;
                }).forEach(orbit => {
                    setTimeout(() => {
                        orbit.hovered = true;
                        setTimeout(() => {
                            orbit.hovered = false;
                        }, 300);
                    }, delay);
                    delay += 50;
                });
            }
            
            handleMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouseX = event.clientX - rect.left;
                this.mouseY = event.clientY - rect.top;
                
                let hoverDetected = false;
                
                // Check for center avatar hover
                const distToCenter = Math.sqrt(
                    Math.pow(this.mouseX - this.centerX, 2) + 
                    Math.pow(this.mouseY - this.centerY, 2)
                );
                
                if (distToCenter < 45) {
                    this.canvas.style.cursor = 'pointer';
                    hoverDetected = true;
                }
                
                // Check if mouse is over any skill
                for (const orbit of this.orbits) {
                    const dx = this.mouseX - orbit.x;
                    const dy = this.mouseY - orbit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Scale hover area with planet size and z position
                    const zScale = this.mapRange(orbit.z, -50, 50, 0.7, 1.3);
                    const hoverRadius = orbit.skill.radius * zScale * 1.2;
                    
                    if (distance < hoverRadius) {
                        orbit.hovered = true;
                        this.canvas.style.cursor = 'pointer';
                        hoverDetected = true;
                    } else {
                        orbit.hovered = false;
                    }
                }
                
                if (!hoverDetected) {
                    this.canvas.style.cursor = 'default';
                }
            }
            
            showSkillDetail(skill) {
                this.selectedSkill = skill;
                this.targetZoomLevel = 1.5;
                
                // Update skill detail content
                this.skillDetailTitle.textContent = skill.name;
                this.skillDetailProgress.style.width = `${skill.level}%`;
                this.skillDetailDesc.textContent = skill.description;
                
                // Show popup with animation
                this.skillDetailPopup.classList.add('active');
            }
            
            hideSkillDetail() {
                this.selectedSkill = null;
                this.targetZoomLevel = 1;
                this.skillDetailPopup.classList.remove('active');
            }
            
            adjustColor(color, amount) {
                // Helper function to darken/lighten colors
                let usePound = false;
                
                if (color[0] === '#') {
                    color = color.slice(1);
                    usePound = true;
                }
                
                const num = parseInt(color, 16);
                let r = (num >> 16) + amount;
                let g = ((num >> 8) & 0x00FF) + amount;
                let b = (num & 0x0000FF) + amount;
                
                r = Math.min(255, Math.max(0, r));
                g = Math.min(255, Math.max(0, g));
                b = Math.min(255, Math.max(0, b));
                
                return (usePound ? '#' : '') + ((g | (r << 8) | (b << 16)).toString(16).padStart(6, '0'));
            }

            // Add the missing applyMouseGravity method
            applyMouseGravity() {
                // Interactive gravity effect when mouse moves near planets
                if (this.mouseX && this.mouseY) {
                    // Calculate distance from mouse to center
                    const dcx = this.centerX - this.mouseX;
                    const dcy = this.centerY - this.mouseY;
                    const centerDist = Math.sqrt(dcx * dcx + dcy * dcy);
                    
                    // Protect center from being affected by mouse gravity
                    if (centerDist < 100) return;
                    
                    // Apply to each orbit
                    this.orbits.forEach(orbit => {
                        // Calculate distance from mouse to planet
                        const dx = this.mouseX - orbit.x;
                        const dy = this.mouseY - orbit.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Skip if too far away or too close
                        if (distance > 150 || distance < 10) return;
                        
                        // Calculate gravitational force (inverse square law)
                        // Weaker gravity for a more subtle effect
                        const force = 0.15 * (1 / Math.max(distance, 30));
                        
                        // Apply gravitational pull - move toward mouse
                        orbit.x += dx * force;
                        orbit.y += dy * force;
                        
                        // Add restoration force to pull planet back toward its orbit
                        // Calculate current distance from center
                        const cdx = orbit.x - this.centerX;
                        const cdy = orbit.y - this.centerY;
                        const currentDist = Math.sqrt(cdx * cdx + cdy * cdy);
                        
                        // Calculate ideal distance (orbit radius)
                        const targetDist = orbit.orbitRadius;
                        
                        // Apply restoration force proportional to displacement
                        const displacement = currentDist - targetDist;
                        const restorationForce = displacement * 0.01;
                        
                        // Direction vector towards center
                        const dirX = cdx / currentDist;
                        const dirY = cdy / currentDist;
                        
                        // Apply restoration force
                        orbit.x -= dirX * restorationForce;
                        orbit.y -= dirY * restorationForce;
                    });
                }
            }
        }
    </script>
</body>
</html>
